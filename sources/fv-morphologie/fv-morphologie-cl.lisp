;; common-lisp main functions;;;;;;;;;;;;;;;;;;;; required;(load "/Users/fred/PWGL-User/User-library/fv-morphologie/package.lisp");(load "/Users/fred/PWGL-User/User-library/fv-morphologie/fv-morphologie.lisp");(load "/Users/fred/PWGL-User/User-library/fv-morphologie/fv-morphologie-encodage.lisp");(load "/Users/fred/PWGL-User/User-library/fv-morphologie/fv-morphologie-io.lisp");(load "/Users/fred/PWGL-User/User-library/fv-morphologie/fv-morphologie-graphs.lisp")(in-package :fv-morphologie);; MENU;;;;;;;;;;;;;;;;;;; 1. DIFFERENTIATION;;; 1.1 SEGMENTATION;;; 1.1.1 INTENSITIES(defmethod int-sign ((seq t) &key (pos nil) (thres 0)) ; old dsign  "Sign of variation of intensities : -1 for decreasing, 1 for increasing, 0 for constant.Optional argument <pos>, if T returns each sign of variations consed to its position in sequence <seq>,or only signs of variations if NIL.Optional argument <thres> is the threshold for detecting only variations higher than <thres>,and variations smaller than <thres> are considered as constant (zéro). Value of <thres> from 0.0 to 1.0, relative to the overall range of intensity values."  (fv-morphologie::dsign seq thres pos))(defmethod def-primitives ((arg1 t) &rest args)  "Defines the symbols to represent each primitive.If using just one argument, the value ':num' calls the symbols -1, 0 and 1, when ':sym' calls the strings 'min' 'flex' 'max'.If using several arguments, each define explicitly each primitive by consing a primitive description in numerical representation - for instance: (1 -1) for acendind-descending - followed by any arbitrary symbol to represent it."   (eval `(fv-morphologie::prim-def ,arg1 ,.args)));;; 1.1.2 MARKS;;; 1.1.3 MOTIFS;;; 1.2 CLASSIFICATION;;; 1.3 CONCATENATION;(menu-separator :in differentiation);(defmethod concaten ((list nil));  :non-generic t;  :class morphologie-box;  (fv-morphologie::concaten list));(defmethod adj-group ((seq nil) (test #'eq) &optional (key nil));  :non-generic t;  :class morphologie-box;  (fv-morphologie::adj-group seq test key));;;;;;;;;;;;;;;;;;; 2. EVALUATION;;; 2.1 DISTANCE;;; DISSEMBLANCE (dissimilarity);(defmethod resembl-p  ((a t) (b t) (thresh .1)  &optional (inex 0) (test #'equalp));  :non-generic t;  :class morphologie-box;  (fv-morphologie::resembl-p a b thresh inex test));;; 2.2 DESCRIPTION - STATS - INFORMATION;;;;;;;;;;;;;;;;;;; 3. DELINEATION;;; 3.1 BUILDING SOME GRAPHS;;; 3.2 MEASURING GRAPHS;;; 3.3 DRAWING(defmethod graph>dot  ((graph t) (distorsion number) (scale t) (out t) &key (shape "ellipse") (legend t) (neato nil))  "Converts a graph (list of edges) into an undirected graph into dot langage to be processed using neato program.Arguments are:graph : the graph, as a structured list.distorsion : amount of distortion allowed for distances fir drawing the graph (from 0.0 for minimum distorsion to 1.0 maximum distorsion)scale : scaling factor for the mininum distanceshape : string or list of strings to define node's shape, using 'neato' definitionsout :if NIL or T, print out in listener;if a string, it defines the pathname of the output. Type of file define output."  (fv-morphologie::graph>dot graph distorsion scale shape out legend (if (or (stringp neato) (pathnamep neato)) neato nil)));;;;;;;;;;;;;;;;;;; 4. ENCODING;;; 4.1 TRANSCODING(defmethod split ((seq t) (marks t))  (if (and seq marks)      (cond ((listp seq)	     (split-list-using-marks seq marks))	    ((stringp seq)	     (split-string seq marks))	    (t seq))      seq))(defmethod concaten ((seq t))  (fv-morphologie::concat seq)); (defmethod transcode ((seq t) (table t) &optional (test #'eq));   (fv-morphologie::transcode seq table test))(defmethod num>base ((num number) (base t))  (fv-morphologie::num-base num base))(defmethod num>alpha ((num number))  (fv-morphologie::num>alpha num))(defmethod alpha>num ((alpha t) &optional (mode nil))  (fv-morphologie::alpha>num alpha))(defmethod list>sym ((list t))  (fv-morphologie::concaten list))(defmethod graph>matrix ((list t))  (fv-morphologie::graph2matrix list));;; 4.2 TOOLS(defmethod filt-median ((seq t) (window number))  "median filter"  (fv-morphologie::median-filter seq window))(defmethod filt-exponential ((seq t) (alpha number) &optional (gamma nil))  "Low-pass filter"  (if (not gamma)      (fv-morphologie::exponential-smoothing seq alpha)    (fv-morphologie::double-exponential-smoothing seq alpha gamma)))(defmethod filt-local-rep ((seq t) &optional (mode nil) (test #'equalp))  "Delete identical values or symbols."  (cond ((eq mode :delete)         (fv-morphologie::rem-local-rep seq test))        ((eq mode :linear)         (if (not (member 'nil (mapcar #'numberp seq)))             (fv-morphologie::nocons= seq test)           (fv-morphologie::filt-local-rep seq :delete test)))        (t (fv-morphologie::filt-local-rep seq :delete test))))(defmethod filt-noise ((seq t) &optional (mode :nozero) (val 0.1))  "Add noise into seq seq"  (fv-morphologie::fnoise seq mode val));;;;;;;;;;;;;;;;;;; 5. IMPORT-EXPORT;;; 5.1 reading files(defmethod read-text ((file t)  (mode t) &key (sep nil) (rem-test nil))  (read-txt-file file :mode mode :marks sep :rem-test rem-test)); (defmethod read-midi ((file)); (defmethod read-sdif ((file));;; 5.2 writing files(defmethod write-list ((list list) (file t) &optional (mode :supersede))  (list-write list file mode))