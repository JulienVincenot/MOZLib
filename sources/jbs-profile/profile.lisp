;;;       JBS-PROFILE for PWGL;;;       Copyright (c) 2009, Jacopo Baboni Schilingi.  All rights reserved.;;;;;;;;;;;;;;;;;BASED ON THE OPEN-MUSIC VERSION DONE in 2001 BY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Jacopo Baboni Schilingi, Nicola Evangelisti e Mikhail Mal ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     Redistribution and use in source and binary forms, with or without;;;     modification, are permitted provided that the following conditions;;;     are met:;;;   * Redistributions of source code must retain the above copyright;;;     notice, this list of conditions and the following disclaimer.;;;   * Redistributions in binary form must reproduce the above;;;     copyright notice, this list of conditions and the following;;;     disclaimer in the documentation and/or other materials;;;     provided with the distribution.;;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR 'AS IS' AND ANY EXPRESSED;;; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED;;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE;;; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY;;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE;;; GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,;;; WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING;;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS;;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.;;;(in-package :cl-user); (defpackage jbs-profile;  (:use :cl :pw)) ; :sb-ext))(in-package :jbs-profile);==========================  MENU   ===============;;; (define-menu jbs-profile :print-name "JBS-Profile");; (in-menu jbs-profile);;================================================================================;=============================  PERTURBATIONS MENU ==============================;================================================================================;;;; (define-menu Perturbations :in jbs-profile);; (in-menu Perturbations);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;       ALEA PERTBURBATION  OX        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun alea-perturbation (list range)  "1.1 - ALEA-PERTURBATIONThis function creates a random perturbation by adding values between to limits. These limits are set in [list] with a single positive value [range]. If you put 10, for instance, the limits are automatically +10 and -10. The ALEA-PERTURBATION for each value coming in is list input will add a value chosen between -10 and +10."  (mapcar #' (lambda (x) (+ x (pw::om-random (- range) range))) list));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;       CTRL-PERTURBATION   OX        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun control-perturbation (list                                  index                                  fact)  "1.2 - CONTROL-PERTURBATIONThis function is useful if you want to createperturbations of a given list, using a secondlist (or a curve) in order to control them.The CONTRO-PERTURBATIONfunction accepts a list in the left input [list] and,in the right input, either a bpf object or a list [index].The CONTRO-PERTURBATION will take foreach element of the incoming in [list] acorrespondent element coming from [index]. If the index [fact] is equal to zero, the [list]does not have any perturbation. To thecontrary the bigger the index is, and thebigger the perturbation will be.Technically  the CONTRO-PERTURBATION function adds the correspondent elementof the second input [index] to the one set in thefirst list [list]. If in [list] you have (10 10 10 10 10 ) and in the second (0 0 1-1 0) and in the third the index is equal to 1the result will be: (10 10 11 9 10). If theindex is equal to 100 the result will be: (10 10 110 -90 10)."  ; :non-generic t  ; :class profile-box  (let* (;(xpoints (unless (listp index) (pw::x-points index)))         (index (pw::om* fact index))         (calcolo-bpf (pw::om+ list                              (pw::om-round                               (pw::om- 1 index) 0)))         (calcolo-numeri (pw::om+ list                                 (pw::om-round                                  index 0))))    (if (listp index)        calcolo-numeri calcolo-bpf))); ; ,(pw::x-transfer (quote ( ( 0.0000 1.0000 ) ( 3.0876 20.0000 ) ( 7.7333 5.6216 ) ( 7.7333 12.7931 ) ( 13.9171 20.0000 ) ( 19.6313 1.0000 ) )) ,(pw::interpolation 0 20 20 0));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     COMPR/EXPAN       OX      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun compression-expansion (list                                    value                                  note?)   "1.3 - COMPRESSION-EXPANSIONThis function creates compressions orexpansions of the intervals of a sequence.In this example intervals are defined by thepitches set in [list]. If the COMPRESSION-EXPANSION has1 in the value input [value], the list set in [list] hasno change. To the contrary if you put anumber bigger than 1 in [value], the intervals willbe expanded, accordingly to the value set in[value]. This value is the multiplier of theintervals. So if you put a number between 0 and 1 theintervals will be compressed; if you put avalue between 0 and -1 the interval will becompressed and reversed (multiplication by-1); if you put values smaller than -1 (forinstance -2, -3, -4...) the intervals willbe expanded and reversed. As the compression and the expansion areoperated on the intervals, the first value (inthis case the first note) is always kept.In the input [note?] you can define with which pitches you want to make this compression or expansion. For instance if you put a C-major scale, the result will have only C-major notes. "  ; :non-generic t  ; :class profile-box  (let* ((calcolo (pw::dx->x                    (first list)                    (mapcar #'(lambda (x) (* x value)) (pw::x->dx list))))         (corretto (when note?                     (notes-change calcolo note? 12))))    (if note? corretto calcolo)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;       HYBRIDATINom-PROFILE     OX        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun hybridatinom-profile (model                                  to-change                                 mode?)  "1.4 - HYBRIDATINom-PROFILE This function changes the directions of asecond profile accordingly with the shape ofa first one.In [model] you enter some pitches having a givenshape. In [to-change] you put the profile you want tochange. The HYBRIDATINom-PROFILEfunction makes a comparison betweenthe intervals of the two profiles. If the notesof the second one have the same directionsof the first profile, these notes are kept asthey are. To the contrary if the notes havedifferent directions from the given model,they are transposed by two criteria set in themenu [mode?]. If [mode?] is equal to INTER, that means that youwant to keep the intervals of the secondprofile and these intervals will changedirections but not their nature. (For instancea fifth stays a fifth, an octave an octave, butthey change the directions).If you chose NOTE in the [mode?] menu, you willkeep the same pitches but transposed inorder to change the directions accordinglyto the first input. "  ; :menu (mode? (:inter ":inter") (:note ":note"))  ; :non-generic t  ; :class profile-box  (pw::om/    (let* ((model (pw::om* model 100))          (to-change (pw::om* to-change 100))          (mode? (Profile-int-note? mode?)))     (funcall (case mode?                (1 'cambia-prof-mel)                (2 'prof-fix-note))              model to-change)) 100));;;================================================================================;=============================  REFLEXIONS MENU =================================;================================================================================;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (define-menu Reflexions :in jbs-profile); (in-menu Reflexions);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;         REFLEXION          OX        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun reflexion (list                       axis                       mode?                       up/down?)  "2.1 - REFLEXIONSThe REFLEXION function creates an upper or lower reflexion of a given profile.In the input [list] you enter the profile you want to reflect. In [limit], you give the value of the reflexion. If in the fourth input the menu [up/down?] is set on up, the function will create a reflexion changing the first profile in order to have only value bigger than the one put in [limit]. In the menu [up/down?] is equal to down, the reflexion will be with values smaller than the one put in [limit].Example, the given profile:----------------------------*--------------------*---*------------*---*------*--------*--------------*-----*------<<<<<<<<<<<<< the axis----------*---*--------------------*--------------------------------------------------------The upper reflexion-----------------------------*---------------------*---*----*-------*----*------*-*---*---*--------------*-----*------<<<<<<<<<<<<< the axis----------0---0---------------------0-----------------------------------------------------------The lower reflexion:-----------------------------0---------------------0---0----0-------0----0------0-0---0---0--------------*-----*------<<<<<<<<<<<<< the axis-*------*-*---*---*--------*---*----*-------*--------*------------------------------------------ATTENTION; the input [mode?] is useful only if you work with pitches.In this case with the input [mode?] you can define if you want to make a reflexion of interval or of pitches. If you put INTER, you will obtain the complementary intervals calculate by the axes. If you put NOTE, you will get the same pitches transposed in order to be as close as possible to the geometric reflexion. "  ; :menu (up/down? (:up ":up") (:down ":down"))  ; :menu (mode? (:inter ":inter") (:note ":note"))  ; :non-generic t  ; :class profile-box  (pw::om/ (let* ((mode? (Profile-int-note? mode?))                 (list (pw::om* list 100))                 (axis (pw::om* axis 100)))            (funcall (case mode?                       (1 'reflex-int)                       (2 'reflex-note)) list axis up/down?))          100));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;         DOUBLE-REFLEXION       OX       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun double-reflexion (list                               limits                              mode?                              inclu?)  "2.2 - DOUBLE-REFLEXIONThis function creates a double reflexion between two given axes.In the first input [list] you put the profile you want to reflect inside two limits. The limits are defined in the second input [limits].This function is recursive and it makes the same reflexion till when all the points can enter the two limits.Example:*--------------------------*-------------*------------*-----------*-*------------*---------*---*------------*-------*-----*------------*-----*-------*------------*---*---------*------------*-*-----------*------------*-------------*---This function makes the reflexion between the two limits.0--------------------------0-------------0------------0-----------0-0------------*---------*---*--------<-<-<- Upper limit--*-*---*---*-*-*-*--------*---*-*-*-*---*---*------*-----*---*---------*-----<-<-<- Lower limit-------0-0-----------0------------0-------------0---If you work with pitches, in this case use the two menus [mode?] and [inclu?]. If you put NOTE [mode?] you will keep the pitches and not the intervals. For this reason if you put YES in [inclu?], you will transpose the pitches to the closest limit. If you put NO, you will remove the pitches that can not fit inside the limits."  ; :menu (mode? (:inter ":inter") (:note ":note"))  ;  :menu (inclu? (:yes ":yes") (:no! ":no!"))  ; :non-generic t  ; :class profile-box  (pw::om/ (let* ((mode? (Profile-int-note? mode?))                 (list (pw::om* list 100))                 (limits (pw::om* limits 100)))            (case mode?              (1 (correttore-doppio-reflex-int list limits))              (2 (correttore-doppio-reflex-note list limits inclu?)))) 100));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;         MULTI-REFLEXION    OX           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun multi-reflexion (list                              limits                             note?)    "2.3 - MULTI-REFLEXIONThis function allows you to make a particularkind of geometrical reflexion.As in the DOUBLE-REFLEXION here youhave a given profile set in the [list] input. Thenyou have to define two limits. Please use thePWGL-SWITCH in order to chose differentlimits to put in the second input [limits].This function works like as shown.The given profile:*--------------------------*-------------*------------*-----------*-*------------*---------*---*------------*-------*-----*------------*-----*-------*------------*---*---------*------------*-*-----------*------------*-------------*---The multi reflexion could be:0--------------------------0-------------0------------0-----------0-0------------*---*-*---*---*--------<-<-<-< Upper limit*---*---*---*-----*--------*---*-----*---*---*--------*---*---*---*-*---*-----<-<-<-< Lower limit-------0-0-----------0------------0-------------0---If you work with pitches, in this case with the input [note?] I ask to use only C-major pitches, for instance. The pitches entered in list are reflected inside the two limits. If you use a pitch set, you will quantify the obtained multi-reflexion through the pitches you are using."  ; :non-generic t  ; :class profile-box  (let* ((list (pw::om* list 100))         (limits (pw::om* limits 100))         (note? (pw::om* note? 100))         (calcolone (quasi-multi-reflexions list limits)))    (if (numberp (first note?))        (notes-change (pw::om/ calcolone 100) (pw::om/ note? 100))      (pw::om/ calcolone 100))));;;================================================================================;=============================  DERIVATIONS MENU =================================;================================================================================;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (define-menu Derivations :in jbs-profile); (in-menu Derivations);; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;         ARITHM-DERIVATION      OX           ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun arithmetic-derivation (list                                   start?                                             gr°)  "3.1 - ARITHMETIC-DERIVATIONThis function is the metaphor of the arithmetic derivation. In [list] you put the profile you to be derived. In [gr°] you ask for which derivation you want: the first, the second, the third and so on.If you want just to use the DERIVATION keep the menu [srtar?] on FIRST.The derivation function can work in tandem with the integration one. If I ask for the second derivation of the second integration of a curve, I obtain the original one. So, in this case it is exactly what I calculate. First with the derivation function I ask for the second derivation. Then with the integration function I ask to reconstitute the origin. To do this I have to set the menu START? on  ORIG set in [start?] and I have to ask the same number of integration that I used in the derivations. This two functions (derivation and integration) allow you to move in the arithmetical space of deriving something and going back to the original. This function is recursive. In this case recursion means which level of the derivation you want to get.If you put 1 you just obtain the first derivation. If you put 2, you will obtain the derivation of the first one; with 3, the derivation of the derivation of the first one; with 4 the derivation of the derivation of the derivation of the original one, and so on."  ; :menu (start? (:first ":first") (:orig ":orig"))  ; :non-generic t  ; :class profile-box  (let* ((start? (Profile-orig-first? start?))         (value (if (= start? 2) (rest list) nil))         (list (if (= start? 1) list (first list))))    (case start?      (1 (append (list (quasi-der-suc list (first list) gr°))                 (prime-note list gr°)))      (2 (append (list (quasi-der-suc list value gr°))                 (prime-note list gr°))))));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;         MEAN-DERIVATION      OX           ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun mean-derivation (list                              gr°                             &optional note?)  "3.2 - MEAN-DERIVATIONThis function calculates the average between each couple of points of a given curve. In this way you can obtain a simplification of a given profile.In [list] you set the curve you want to be derived.In [gr] you set which derivation you want: the first, the second, the third, and so on. ATTENTION, you can have only a numbers of derivation equal to the length of the points constituting the profile minus 1.If you work with pitches,you can quantify theresult with the pitches you have put in the [note?] input.This function is recursive. In this case recursion means which level of the derivation you want to get.If you put 1 you just obtain the first derivation. If you put 2, you will obtain the derivation of the first one; with 3, the derivation of the derivation of the first one; with 4 the derivation of the derivation of the derivation of the original one, and so on."  ; :non-generic t  ; :class profile-box  (let* ((list (pw::om* list 100))         (calcolo (if (= 1 gr°) (med-fix list)                    (mean-derivation (med-fix list) (- gr° 1)  note?))))        (if (numberp (first note?)) (notes-change (pw::om/ calcolo 100) note? 48)       (pw::om/ calcolo 100))));;;;==============================================================================================;                                       AVERAGE DERIVATION;;;==============================================================================================;;(defun average-derivation (list gr)    "3.3 - AVERAGE-DERIVATIONThis function calculates the average between all the elements (and not only for each couples of elements) of a given profile.In [list] you put the profile you want to be derived. In [gr] you set which level of the derivation you want: the first, the second, the third, and so on.Because this function is recursive, it can happens that after a certain number of derivation you obtain a division by zero. SO for this reason, look at the patch and try out the number I suggest you, fir this example. This function is useful to make another kind of simplification of a curve.This function is recursive. In this case recursion means which level of the derivation you want to get.If you put 1 you just obtain the first derivation. If you put 2, you will obtain the derivation of the first one; with 3, the derivation of the derivation of the first one; with 4 the derivation of the derivation of the derivation of the original one, and so on."  ; :non-generic t  ; :class profile-box  (if (= gr 1) (se-derivo list)    (average-derivation (pw::om+ (baricentro (se-derivo list)) (pw::x->dx (se-derivo list)))                        (- gr 1))));;;;==============================================================================================;                                    BARYCENTRE DERIVATION;;;==============================================================================================;;;(defun barycentre-derivation (list gr)  "3.4 - BARYCENTRE-DERIVATIONThis function creates another possible simplification of a given profile.In [list] you put the profile you want to be derived. In [gr] you set which level of the derivation you want: the first, the second, the third, and so on.This way of deriving calculates each time the barycentre of a list and uses it to constitute the derivation.The criterium of derivations isbased on the barycentre of the list itself.ATTENTION, you can have only a number of derivations equal to the length of the points constituting the profile minus 1.This function is recursive. In this case recursion means which level of the derivation you want to get.If you put 1 you just obtain the first derivation. If you put 2, you will obtain the derivation of the first one; with 3, the derivation of the derivation of the first one; with 4 the derivation of the derivation of the derivation of the original one, and so on.  "  ; :non-generic t  ; :class profile-box  (if (= gr 1) (der-fix-arb list)    (barycentre-derivation (der-fix-arb list) (- gr 1))));;;;==============================================================================================;                                   MIN-MAX-POINTS;;;==============================================================================================;(defun min-max-points (list)  "3.5 - MIN-MAX-DERIVATIONThis is the last way I found to make a simplification of a profile.The MIN-MAX-DERIVATION gives you only the point of minimum and maximum of a given profile."  ; :non-generic t  ; :class profile-box  (let ((ris nil)        (calcolo (morph::min-flex-max list :every)))        (pw::flat (list (first list) (mapcar #' (lambda (x) (third x)) calcolo) (first (last list))))));;;================================================================================;=============================  INTEGRATIONS MENU =================================;================================================================================;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (define-menu Integrations :in jbs-profile); (in-menu Integrations);;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        ARITHMETIC INTEGRATION      OX           ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun arithmetic-integration (list                                    start?                                    gr°)  "4.1 - ARITHMETIC-INTEGRATIONThis function is the metaphor of the arithmetic integration. In [list] you put the profile you to be integrated. In [gr°] you ask for which derivation you want: the first, the second, the third and so on.ATTENTION: this function is very special, if you want just to obtain the integration keep the menu [start?] on FIRST.The integration function can work in tandem with the derivation one. If I ask for the second integration of the second derivation of a curve, I obtain the original one. So, in this case it is exactly what I calculate. First I can calculate the integration of a profile and then with the derivation function (see also the tutorial 3.1 of this same library) I ask to reconstitute the origin. To do this I have to set the menu START? on ORIG set in [start?] and I have to ask the same number of derivations that I used in the integrations. These two functions (derivation and integration) allow you to move in the arithmetical space of deriving something and going back to the original. This function is recursive. In this case recursion means which level of the integration you want to get.If you put 1 you just obtain the first integration. If you put 2, you will obtain the integration of the first one; with 3, the integration of the integration of the first one; with 4 the integration of the integration of the integration of the original one, and so on."  ; :menu (start? (:first ":first") (:orig ":orig"))  ; :non-generic t  ; :class profile-box  (let* ((start? (Profile-baric-first? start?))         (value (if (= start? 2) (rest list) nil))         (list (if (= start? 1) list (first list))))    (case start?      (1 (append (list (quasi-integr-suc list value gr°))                 (list (baricentro list))))      (2 (append (list (quasi-integr-suc1 list 2 value gr°))                 (list (baricentro list)))))));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     GEOMETRIC-INTEGRATION (OLD INTERLOCK)      OX    ;;;;;;;;;;;;;;;;;;;;;(defun geometric-integration (list1 list2 gr)   "4.2 - GEOMTRIC-INTEGRATIONThis function creates a sort of integration of a given profile.In [list1] you put the profile. In [list2] you put the numbers you want to be used to make the given profile more complex.In [gr] you can decide how many times you want the original profile to be transformed into a more complex one. So in [gr] you ask for which level you want: the first, the second, the third and so on.Technically, this function inserts the elements you put in [list2] between two consecutive elements of the original profile. As this function is recursive, if you put 1 in [gr] you get the first insertion. But if you put number bigger than 1, each time you will insert the elements in [list2] in each new couple of consecutive elements of the previous result.This function is recursive. In this case recursion means which level of the integration you want to get.If you put 1 you just obtain the first integration. If you put 2, you will obtain the integration of the first one; with 3, the integration of the integration of the first one; with 4 the integration of the integration of the integration of the original one, and so on.It is the Old inerlock"  ; :non-generic t  ; :class profile-box  (if (= gr 1) (inter-profile list1 list2)    (geometric-integration (inter-profile list1 list2)               (pw::permut-circ list2 (1- (length list1)))               (- gr 1))));;;;==============================================================================================;                                    BARYCENTRE INTEGRATION;;;==============================================================================================;;(defun barycentre-integration (list gr)  "4.3 - BARYCENTRE-PROFILEThis functions gives another way of making a profile more complex.In [list] you put the profile. With [gr] you define which level of integration you want. This function is recursive. In this case recursion means which level of the integration you want to get.If you put 1 you just obtain the first integration. If you put 2, you will obtain the integration of the first one; with 3, the integration of the integration of the first one; with 4 the integration of the integration of the integration of the original one, and so on."  ; :non-generic t  ; :class profile-box  (if (= gr 1) (int-fix-arb list)    (barycentre-integration (int-fix-arb list) (- gr 1))));;;;================================================================================;=============================  INTERPOLATIONS MENU =================================;================================================================================;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (define-menu Interpolations :in jbs-profile); (in-menu Interpolations);; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;          DYNAMIC-INTERPOLATION      OX   ;;;;;;;;;;;;;;;;;;;;;;(defun dynamic-interpolation (begin                                    end                                    steps                                   tab                                    inclu?                                   note?)              "5.1 - DYNAMIC INETRPOLATIONThis function creates an interpolationbetween two lists [begin and end]. In [begin] youput the starting profile. In [end] the ending one.In [steps] you define how many steps do youwant. In [tab] you can enter a bpf to define howgoing from the first list to the second.ATTENTION: if you do not specify any bpf,the interpolation is linear.In the menu [INCLU?] you can define ifyou want or not (with YES and NO!) thestarting and ending lists.With NOTE? You can define if you want ornot a pitch quantification. If you put a single chord, you have only one chord for the holeinterpolation; if you put a list of chords you can define a specific chord for each step ofthe interpolation. BE CAREFUL: if you have only a list withtwo chords, but you ask for 10 steps, thechords will be repeated in a circular way.BE CAREFUL TOO: the staring point andthe ending one are not included in the pitchquantification. "  ;  :menu (inclu? (:yes ":yes") (:no! ":no!"))  ; :non-generic t  ; :class profile-box  (let* ((inclu? (Profile-inclu? inclu?))         (initio (pw::list! begin))         (endio (pw::list! end))         (le-note (when note?                    (if (atom (first note?))                        (list note?) note?)))         (interpo (pw::mat-trans (mapcar #'(lambda                                                    (liste1 liste2)                                              (inter-dyn0 liste1 liste2 steps                                                         tab                                                          2))                                         initio endio)))         (con-scala (when note?                      (if (= (length begin) 1)                          (pw::list-explode                           (notes-change (pw::flat interpo) (pw::flat le-note) 48)                           (length interpo))                        (cambia-ogni-accordo interpo le-note))))         (fine-calcolo (append (list begin)                               (if note? con-scala interpo)                               (list end))))    (case inclu?      (1 fine-calcolo)      (2 (butlast (rest fine-calcolo))))));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        MULTI-INTEPOLATION      OX          ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun multi-interpolation (prof                                  n-elmt                                  tab                                 note?)  "5.2 - MULTI-INTERPOLATIONThis function, allows you to create a series of interpolations, with the same criteria developed in the DYNAMIC-INTERPOLATION. (See also tutorial 5.1 of this same Library).The goal is to make an interpolation between each sub-list you enter in [prof].In [prof] you put a list of lists. Each sub-list is a point for the interpolation? In [n-elmt] you define how many steps do you have for each point of the interpolation.BE CAREFUL: if the number of step is inferior to the number of interpolations, (defined this last one with the number of sub-lists), the steps will be read in a circular way till the end of the last interpolation.In [tab] you define the curve (bpf) that will be used for the each interpolation. If you do not put any bpf, all the interpolations will be linear. If you put only one bpf, all the interpolations will follow the same shape. If you put as curves as the interpolations, for each of them the algorithm will use a specific bpf in the order you have define. BE CAREFUL: if the number of bpf is inferior to the number of interpolations, (defined this last one with the number of sub-lists), the bpf will be read in a circular way till the end of the last interpolation.In [note?] you put the pitch quantification (if needed). So, if you put only one chord, you will have a global pitch quantification. BUT BE CAREFUL: the defined sub-lists of the interpolations will not be affected by the pitch quantification. If you put more than one chord you can define a specific pitch field for each interpolation between each sub-list. BE CAREFUL: if the number of step is inferior to the number of chords, (defined this last one with the number of sub-lists), the chords will be read in a circular way till the end of the last interpolation."  ; :non-generic t  ; :class profile-box  (let* ((steps (pw::list! n-elmt))         (interpo (dyn-mult prof steps tab))         (interpo-note (when note?                         (if (atom (first prof))                             (interpol-mult-note? (pw::list-explode prof (length prof)) steps tab note?)                           (interpol-mult-note? prof steps tab note?)))))        (if note? interpo-note interpo)));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        BPF-INTERPOLATION   OX         ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun BPF-interpolation  (bpf1  bpf2                                samples                                approx                                steps                                tab                                )  "5.3 - BPF-INTERPOLATIONThis function creates an interpolation of pbfs.In [bpf1] you define the starting bpf. In [bpf2] the ending.In [samples] you put how many samples have to be used to describe each bpf.In [approx] you define the last approximation. 2 is for semitones, 4 for fourth of tone, 100 hundred for hundreds of tones...In [steps] you enter how many steps do you want between the starting and the ending bpfs.In [tab] you can define how to move (following a bpf) from the starting to the ending bpf."  ; :non-generic t  ; :class profile-box  (let* ((xbpf1 bpf1) ; (pw::x-points bpf1)         (xbpf2 bpf2) ; (pw::x-points bpf2)         (x-max-bpf1 (pw::list-max xbpf1))         (x-min-bpf1 (pw::list-min xbpf1))         (x-max-bpf2 (pw::list-max xbpf2))         (x-min-bpf2 (pw::list-min xbpf2))         (databpfy1 bpf1)  ;  x-transfer + interpolation (pw::pwgl-sample bpf1 samples)         (databpfx1 (pw::interpolation x-min-bpf1 x-max-bpf1 samples 1))         (databpfy2 bpf2)   ;  x-transfer + interpolation (pw::pwgl-sample bpf2 samples)         (databpfx2 (pw::interpolation x-min-bpf2 x-max-bpf2 samples 1))         (coordonx (pw::om-round (interpol-tab databpfx1 databpfx2                                               steps tab 1) approx))         (coordony (pw::om-round (interpol-tab databpfy1 databpfy2                                               steps tab 1) approx)))    (pw::mat-trans (list coordonx coordony))));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        PROFILE-INTERPOLATION          ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun profile-interpolation  (prof1                                      prof2                                    steps                                    nbr-n                                    tab                                    note?                                    precis                                    approx)  "5.4 - PROFILE-INETRPOLATIONThis function creates an interpolation between two lists having two different numbers of elements.In [prof1] you put the starting profile. In [prof2] the ending one.In [steps] you define how many steps do you want. ATTENTION: if you put 12 the whole interpolation has 14 sub-lists. This because I consider steps independent from the starting and ending profiles.In [nbr-n] you can define how many numbers will constitute each sub-list.ATTENTION: if you put a number of lengths of sub-groups smaller than the number of steps, the NBR-N will be read in a circular way. ATTENTION TOO: the starting and ending point are not affected by NBR-N.In tab [tab] you can enter a bpf to define how going from the first list to the second. If you do not define any bpf the interpolation will be linear.With NOTE? you can define if you want or not a pitch quantification. You can choose not to have chords, (first possibility), to have only one chord for the whole interpolation (second possibility), or to have as many as you want chords for each step of the interpolation. BE CAREFUL: if you have only a list with two chords, but you ask for 12 steps, the chords will be repeated in a circular way.BE CAREFUL TOO: the staring point and the ending one are not affected in the pitch quantification.In [precis] you have to decide the sample rate to be as precise as you want. ThisPRECIS index is a multiplication factor to up-sampling the given profiles in order to have a good interpolation quality. ATTENTION: the bigger is this number the slower is the computation.In [approx] you can define the pitch quantification:2 is for semitone, 4 is for quarter of tone, 8 for eight of tone, and so on."  ; :non-generic t  ; :class profile-box  (let* ((prof1 (pw::list! prof1))         (prof2 (pw::list! prof2))         (lungo1 (length prof1))         (lungo2 (length prof2))         (le-note (when note?                    (if (atom (first note?))                        (list note?) note?)))         (bpf1 (pw::mk2D-object :bpf (list (pw::arithm-ser 0 (* 10 precis) (1- (* precis 10 lungo1))) prof1)))         (bpf2 (pw::mk2D-object :bpf (list (pw::arithm-ser 0 (* 10 precis) (1- (* precis 10 lungo2))) prof2)))         (liste-interpolations (BPF-interpolation (first bpf1) (first bpf2)                                                   (* precis                                                      (pw::list-max (list lungo1 lungo2)))                                                  2 steps tab))         (nbr-n (cond                  ((null nbr-n) (lin-list lungo1 lungo2 steps))                 ((numberp nbr-n) (pw::create-list steps 0 nbr-n))                 (t (pr nbr-n (pw::create-list steps 0 nbr-n)) )))                                                                                          ;;;;;;;;;;;;;;;;; ICI CORRIGER SAMPLE         (calcolone (mapcar #'(lambda (x ech) (pw::approx-midi (pw::pwgl-sample               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                                (pw::mk2D-object :bpf x) ech) approx)) liste-interpolations nbr-n))         (con-note (when note?                     (append (list prof1)                             (cambia-ogni-accordo (pw::flat-once calcolone) le-note)                             (list prof2)))))    (if note? con-note (append (list prof1) (pw::flat-once calcolone) (list prof2)))));;============================================================================;=============================  UTILITIES MENU ==============================;============================================================================;; (define-menu utilities :in jbs-profile); (in-menu utilities);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   NOTE CHANGE OX    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun notes-change (pitch scale &optional mod)  "6.1 - NOTE-CHANGEThis function [1] makes a pitch quantification.In [a] you put a list of pitches.In [b] the scale that will be used for quantification.ATTENTION: the approximation of the quantification is done by floor.You can chose the modulo in [mod]."  ; :non-generic t  ; :class profile-box  (let* ((pitch (pw::om* (pw::list! pitch) 100))         (scale (pw::om* (pw::list! scale) 100))         (modsca (pw::om-floor (pw::sort-list                                (pw::rem-dups (pw::g-mod (pw::om/ scale (/ 100 (/ mod 12))) mod)))))         (pitmods (pw::g-mod (pw::om/ pitch (/ 100 (/ mod 12))) mod))         (octa (octave pitch))         (posdifs (mapcar #'(lambda (p) (position (pw::list-min (pw::om-abs (pw::om- modsca p)))                                                  (pw::om-abs (pw::om- modsca p))))                          pitmods)))    (pw::om/ (mapcar #'(lambda (index octave) (makenote index octave mod))                    (pw::posn-match modsca posdifs)                    octa) 100)));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;         RANGE-APPROX      OX          ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun range-approx (list                           limits inclu?)  "6.2 - RANGE-APPROXThis function transposes a list of pitches [list] inside two limits [limits]. If the transposition does not fit inside the two limits, you can chose to remove the pitches that are not included using the menu INCLU? with NO!. If you put YES, then the pitches are transposed as close as possible to the upper and lower limits."  ;  :menu (inclu? (:yes ":yes") (:no! ":no!"))  ; :non-generic t  ; :class profile-box  (double-reflexion list limits :note inclu?));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           WEIGHT-AVERAGE              ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun weight-average (list)  "6.3 - WEIGHT-AVERAGE This function calculates the barycentre of a given list [list], by doing the global average."  ; :non-generic t  ; :class profile-box  (baricentro list));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           BPF-COLLECTOR      OX          ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun bpf-collector (indexes precision bpf1 &rest bpfs)  "6.4 - BPF-COLLECTORIt collects several bpfs following the posn-match indexes set in indexes. In the first input you set the posn-match indexes that reorders the bpfs. In precision you set how many x-point will be used to sample each bpf. In bpf1 and bpfs you put your curves in a 2D-Editor with bpf. The bpf collector re-order the bpfs one after the other following the posn-match indexes you set in indexes."  ; :non-generic t  ; :class profile-box  (let* ((ordinamento (pw::posn-match (pw::x-append bpf1 bpfs) indexes))         (ros nil)         (y-points (dolist (y ordinamento (nreverse ros))                     (push (system::pwgl-sample y precision) ros)))         (intervalli (pw::flat (mapcar #' (lambda (x)                                            (pw::x->dx x))                                       y-points))))        (pw::dx->x (first (first y-points)) intervalli)));; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;              FOUR-FORMS      OX          ;;;;;;;;;;;;;;;;;;;;;;;;;;(defun four-forms (list forms?)  "6.5 - FOUR-FORMSThis function creates the four historical forms of a given pitch list:the original, the reversed, the inversed, the reversed-inversed. With the menu Four-forms-menu? you can choose which of them you want."  ; :menu (forms? (:original ":original") (:reverse ":reverse")                ; (:inversion ":inversion") (:rever-inver ":rever-inver"))  ; :non-generic t  ; :class profile-box    (let ((forms? (Four-forms-menu? forms?)))    (case forms?      (1 list)      (2 (reverse list))      (3 (pw::om+ (pw::om* (pw::om- list (first list)) -1) (first list)))      (4 (reverse (pw::om+ (pw::om* (pw::om- list (first list)) -1) (first list)))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; at the end;; (install-menu jbs-profile)